#!/usr/bin/perl

use strict;

use Carp;
use Client;
use Date::Manip;
use Getopt::Long;
use IO::Handle;
use JSON::XS;

autoflush STDOUT 1;
autoflush STDERR 1;

my $config_name = "config.json";
my $body_name;
my $queue_name;
my $debug = 0;
my $quiet_no_body = 0;

GetOptions(
  "config=s" => \$config_name,
  "body=s"   => \$body_name,
  "queue=s"  => \$queue_name,
  "debug"    => \$debug,
  "quiet_no_body"    => \$quiet_no_body,
) or die "$0 --config=foo.json --body=Bar --queue=queue.file\n";

my $client = Client->new(config => $config_name);
my $body_id;
if ($body_name) {
  my $planets = $client->empire_status->{planets};
  for my $id (keys(%$planets)) {
    $body_id = $id if $planets->{$id} =~ /$body_name/;
  }
  exit(1) unless $body_id || !$quiet_no_body;
  die "No matching planet for name $body_name\n" unless $body_id;
} else {
  $body_id = $client->empire_status->{home_planet_id};
}

my $buildings = $client->body_buildings($body_id);
exit(0) if grep($_->{pending_build}, values(%{$buildings->{buildings}}));

$body_name = $client->body_status($body_id)->{name};

$queue_name ||= "$body_name.queue";
$queue_name =~ s/\s+/_/g;

print "Reading build queue $queue_name\n" if $debug;
my $file;
open($file, "<", $queue_name) or die "Couldn't read queue file $queue_name: $!\n";
my @queue = (<$file>);
close $file;

my $buildable;
my $abort;
for my $j ($[..$#queue) {
  exit(0) if $abort;
  my $command = $queue[$j];
  chomp $command;
  $command =~ s/wait quietly/-wait/;
  my $quiet;
  $quiet = 1 if $command =~ s/^\-//;
  $abort = 1 if $command =~ s/^\!//;
  my $sleepy = (localtime())[1] % 30;

  print "Inspecting $command\n" if $debug;
  if ($command =~ /^wait *(.*)/) {
    my $until = $1;
    my $date = ParseDate($until);
    if (!$quiet) {
      emit("Waiting until ".UnixDate($date, "%Y-%m-%d %H:%M"));
      splice(@queue, $j, 1, "-$queue[$j]");
      write_queue();
    }
    if (UnixDate($date, "%s") < time()) {
      splice(@queue, $j, 1);
      write_queue();
    } else {
      exit(0);
    }
  }
  if ($command =~ /^build (.*)/o) {
    my $name = $1;
    my ($x, $y);
    ($x, $y) = ($1, $2) if $name =~ s/^(-?\d) (-?\d) //;
    $buildable ||= $client->body_buildable($body_id);
    my $reqs = $buildable->{buildable}{$name};
    unless ($reqs && $reqs->{build}{can}) {
      emit("Cannot build $name: $reqs->{build}{reason}[1]") unless $quiet && $sleepy;
      if (!$quiet) {
        splice(@queue, $j, 1, "-$queue[$j]");
        write_queue();
      }
      next;
    }
    my $build = $client->body_build($body_id, $name, $x, $y);
    if ($build) {
      emit("Building $name, complete at ".Client::format_time(Client::parse_time($build->{building}{pending_build}{end})));
      splice(@queue, $j, 1);
      @queue = map { s/^\-//; $_; } @queue;
      write_queue();
      exit(0);
    }
  }
  if ($command =~ /^upgrade (\d+) (.*)/o) {
    my $level = $1;
    my $name = $2;

    for my $id (keys %{$buildings->{buildings}}) {
      my $building = $buildings->{buildings}{$id};
      print "Matching against $building->{level} $building->{name}\n" if $debug;
      if ($building->{name} eq $name && (!$level || $building->{level} == $level)) {
        my $view = $client->building_view($building->{url}, $id);
        unless ($view && $view->{building}{upgrade}{can}) {
          emit("Cannot upgrade $level $name: $view->{building}{upgrade}{reason}[1]") unless $quiet && $sleepy;
          if ($queue[$j] !~ /^\-/) {
            splice(@queue, $j, 1, "-$queue[$j]");
            write_queue();
          }
          next;
        }
        my $upgrade = $client->building_upgrade($building->{url}, $id);
        emit("Upgrading $building->{level} $name, complete at ".Client::format_time(Client::parse_time($upgrade->{building}{pending_build}{end})));
        splice(@queue, $j, 1);
        @queue = map { s/^\-//; $_; } @queue;
        write_queue();
        exit(0);
      }
    }
  }
  if ($command =~ /^resources(.*)/o) {
    my $args = $1;
    my @args = split(/,/, $args);
    grep(s/^\s*//, @args);
    grep(s/\s*$//, @args);

    my $max_level = 15;
    for my $arg (@args) {
      $max_level = $1 if $arg =~ /max level (\d+)/;
    }

    my $status = $client->body_status($body_id);
    my %ratio;
    for my $type (qw(food ore water energy)) {
      $ratio{$type} = $status->{"${type}_stored"} / $status->{"${type}_capacity"};
    }
    my $type = (sort { $ratio{$a} <=> $ratio{$b} } keys %ratio)[0];
    emit("Want to upgrade $type production") unless $quiet && $sleepy;

    my @buildings = map { { id => $_, %{$buildings->{buildings}{$_}} } } keys %{$buildings->{buildings}};
    @buildings = sort { $b->{level} <=> $a->{level} } @buildings;
    my @pruned;
    for my $building (@buildings) {
      next if grep(/^0x ?$building->{name}/, @args);
      grep(s/^(\d+)x ?$building->{name}/($1 - 1)."x $building->{name}"/e, @args);
      push(@pruned, $building);
    }
    @buildings = @pruned;
    @buildings = grep { $_->{level} < $max_level } @buildings;
    @buildings = grep { $_->{"${type}_hour"} > 0 } map { populate_building_with_production($_) } @buildings;
    for my $building (@buildings) {
      $building->{cost_time} = List::Util::max($building->{upgrade}{cost}{time} / 3600, map { $building->{upgrade}{cost}{$type} / $status->{"${_}_hour"} } qw(food ore water energy));
      $building->{payoff} = $building->{upgrade}{production}{"${type}_hour"} - $building->{"${type}_hour"};
      $building->{payoff_ratio} = $building->{payoff} / $building->{cost_time};
    }

    @buildings = sort { $b->{payoff_ratio} <=> $a->{payoff_ratio} } @buildings;
    if (!($quiet && $sleepy)) {
      for my $building (@buildings) {
        printf("%s payoff ratio: %8.3f: %d %s\n", $type, $building->{payoff_ratio}, $building->{level}, $building->{name});
      }
    }

    my $building = $buildings[0];
    unless ($building->{upgrade}{can}) {
      emit("Cannot upgrade $building->{level} $building->{name}: $building->{upgrade}{reason}[1]") unless $quiet && $sleepy;
      if ($queue[$j] !~ /^\-/) {
        splice(@queue, $j, 1, "-$queue[$j]");
        write_queue();
      }
      next;
    }
    else {
      my $upgrade = $client->building_upgrade($building->{url}, $building->{id});
      emit("Upgrading $building->{level} $building->{name}, complete at ".Client::format_time(Client::parse_time($upgrade->{building}{pending_build}{end})));
      @queue = map { s/^\-//; $_; } @queue;
      write_queue();
      exit(0);
    }
  }
}

sub populate_building_with_production {
  my $building = shift;
  # print "Viewing data for $building->{level} $building->{name}\n";
  my $result = $client->building_view($building->{url}, $building->{id})->{building};
  return { %$building, %$result };
}

sub emit {
  my $message = shift;
  print Client::format_time(time())." $body_name: $message\n";
}

sub write_queue {
  my $file;
  open($file, ">", "$queue_name.$$") or croak "Could not write queue file $queue_name.$$: $!";
  print $file join("", @queue);
  close $file;
  rename("$queue_name.$$", $queue_name) or croak "Could not rename queue file $queue_name.$$ to $queue_name: $!";
}
